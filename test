import os
import uuid
import requests
import json
import time
import subprocess
import asyncio
import aiohttp
import threading
import psutil
import sqlite3
import shutil
from datetime import datetime
from colorama import init, Fore, Style
from threading import Lock
import base64
from urllib.parse import urlparse, parse_qs
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Protocol.KDF import PBKDF2

init(autoreset=True)

def set_console_title(title):
    if os.name == 'nt':  
        os.system(f'title {title}')

def clear_console():
    if os.name == 'nt':  
        os.system('cls')
    else:
        os.system('clear')

set_console_title('Rokid Manager - UGPhone Rejoin')

SERVER_LINKS_FILE = "server-link.txt"
ACCOUNTS_FILE = "account.txt"
interval = None
stop_webhook_thread = False
webhook_thread = None
status_lock = Lock()
rejoin_lock = Lock()

package_statuses = {}
username_cache = {}
CACHE_FILE = "username_cache.json"
cache_save_interval = 600 
stop_event = threading.Event()

# webhook
CONFIG_FILE = "config-wh.json"
webhook_url = None
device_name = None
interval = None
stop_webhook_thread = False
webhook_thread = None

FDATA = "data_tab.json"

if not os.path.exists(FDATA):
	with open(FDATA, "w") as f:
		json.dump([], f, indent=4)
		f.close()
    
executors = {
    "Fluxus": "/storage/emulated/0/Fluxus/",
    "Codex": "/storage/emulated/0/Codex/",
    "Arceus X": "/storage/emulated/0/Arceus X/",
    "Delta": "/storage/emulated/0/Delta/",
    "Cryptic": "/storage/emulated/0/Cryptic/"
}

workspace_paths = []

for executor, base_path in executors.items():
    workspace_paths.append(f"{base_path}Workspace")   
    workspace_paths.append(f"{base_path}workspace")   

    
lua_script_template = '''
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")
local os_time = os.time()

getgenv().StopUpdate = false

GuiService.ErrorMessageChanged:Connect(function()
    local Code = GuiService:GetErrorCode().Value
    if Code >= Enum.ConnectionError.DisconnectErrors.Value then
        getgenv().StopUpdate = true
    end
end)

repeat wait() until game.JobId ~= nil

-- exec status
local function writeExecutorStatus(status)
    local username = Players.LocalPlayer.Name  -- Get the player's username
    pcall(function() 
        writefile("executor_check_" .. username .. ".txt", status .. ":" .. os_time)  -- username and timestamp
    end)
end

-- initial
writeExecutorStatus("working")

-- Monitor if player teleports or periodically update the status
while wait(1) do
    if not getgenv().StopUpdate and Players.LocalPlayer and Players.LocalPlayer:FindFirstChild("PlayerScripts") then 
        -- Continuously update the working status
        writeExecutorStatus("working")
    end
end
'''

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def print_header():
    header = r"""
  _____       _    _     _   __  __                                   
 |  __ \     | |  (_)   | | |  \/  |                                  
 | |__) |___ | | ___  __| | | \  / | __ _ _ __   __ _  __ _  ___ _ __ 
 |  _  // _ \| |/ / |/ _` | | |\/| |/ _` | '_ \ / _` |/ _` |/ _ \ '__|
 | | \ \ (_) |   <| | (_| | | |  | | (_| | | | | (_| | (_| |  __/ |   
 |_|  \_\___/|_|\_\_|\__,_| |_|  |_|\__,_|_| |_|\__,_|\__, |\___|_|   
                                                       __/ |          
                                                      |___/                     
"""
    print(Fore.LIGHTCYAN_EX + header + Style.RESET_ALL)
    print(Fore.LIGHTMAGENTA_EX + "Made by Dreamon - Free Version | https://discord.gg/HgSePhP3E5" + Style.RESET_ALL)

# Function to detect available executors and write the Lua script to their Autoexec folder
def detect_and_write_lua_script():
    detected_executors = []

    for executor_name, base_path in executors.items():
        # Define all possible paths for Autoexec/Autoexecute
        possible_autoexec_paths = [
            os.path.join(base_path, "Autoexec"),
            os.path.join(base_path, "Autoexecute")
        ]

        lua_written = False  # To track if Lua file is successfully written

        for path in possible_autoexec_paths:
            if os.path.exists(path):
                lua_script_path = os.path.join(path, "executor_check.lua")
                
                try:
                    with open(lua_script_path, 'w') as file:
                        file.write(lua_script_template)  
                    lua_written = True  
                    break  

                except Exception:
                    pass  

        if lua_written:
            detected_executors.append(executor_name)

    return detected_executors

def capture_screenshot():
    screenshot_path = "/storage/emulated/0/Download/screenshot.png"
    try:
        os.system(f"/system/bin/screencap -p {screenshot_path}")
        print(Fore.GREEN + f"[ Rokid Manager ] - Screenshot saved to: {screenshot_path}" + Style.RESET_ALL)
        return screenshot_path
    except Exception as e:
        print(Fore.RED + f"[ Rokid Manager ] - Error capturing screenshot: {e}" + Style.RESET_ALL)
        return None  

def get_system_info():
    cpu_usage = psutil.cpu_percent(interval=1)
    memory_info = psutil.virtual_memory()
    uptime = time.time() - psutil.boot_time()
    system_info = {
        "cpu_usage": cpu_usage,
        "memory_total": memory_info.total,
        "memory_available": memory_info.available,
        "memory_used": memory_info.used,
        "uptime": uptime
    }
    return system_info

def load_config():
    global webhook_url, device_name, interval
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r") as file:
            config = json.load(file)
            webhook_url = config.get("webhook_url")
            device_name = config.get("device_name")
            interval = config.get("interval")
    else:
        webhook_url = None
        device_name = None
        interval = None

def save_config():
    config = {
        "webhook_url": webhook_url,
        "device_name": device_name,
        "interval": interval
    }
    with open(CONFIG_FILE, "w") as file:
        json.dump(config, file)

def start_webhook_thread():
    global webhook_thread, stop_webhook_thread
    if webhook_thread is None or not webhook_thread.is_alive():
        stop_webhook_thread = False
        webhook_thread = threading.Thread(target=send_webhook)
        webhook_thread.start()

def send_webhook():
    global stop_webhook_thread
    while not stop_webhook_thread:
        screenshot_path = capture_screenshot()
        if screenshot_path is None:  
            continue

        if not os.path.exists(screenshot_path):
            print(Fore.RED + "[ Rokid Manager ] - Screenshot file does not exist." + Style.RESET_ALL)
            continue

        system_info = get_system_info()
        embed = {
            "color": 16776961,
            "fields": [
                {"name": "Device Name", "value": f"`{device_name}`", "inline": True},
                {"name": "CPU Usage", "value": f"`{system_info['cpu_usage']}%`", "inline": True},
                {"name": "Memory Used", "value": f"`{system_info['memory_used'] / system_info['memory_total'] * 100:.2f}%`", "inline": True},
                {"name": "Memory Available", "value": f"`{system_info['memory_available'] / system_info['memory_total'] * 100:.2f}%`", "inline": True},
                {"name": "Total Memory Capacity", "value": f"`{system_info['memory_total'] / (1024 ** 3):.2f} GB`", "inline": True},
                {"name": "Uptime", "value": f"`{system_info['uptime'] / 3600:.2f} hours`", "inline": True}
            ],
            "image": {"url": "attachment://screenshot.png"},
            "footer": {
                "text": "discord.gg/rokidmanager",
                "icon_url": "https://images-ext-1.discordapp.net/external/J_N9HjmqaSHjVLUKVZiw-637-Aqw6NnlGSgwn44JnVU/%3Fsize%3D4096/https/cdn.discordapp.com/icons/1283014545513906278/5d85563d6b5c6d7b2a891fd673fad789.png?format=webp&quality=lossless"
            },
            "author": {
                "name": "Rokid Manager",
                "icon_url": "https://images-ext-1.discordapp.net/external/J_N9HjmqaSHjVLUKVZiw-637-Aqw6NnlGSgwn44JnVU/%3Fsize%3D4096/https/cdn.discordapp.com/icons/1283014545513906278/5d85563d6b5c6d7b2a891fd673fad789.png?format=webp&quality=lossless"
            }
        }
        payload = {
            "embeds": [embed],
            "username": device_name
        }

        with open(screenshot_path, "rb") as file:
            response = requests.post(
                webhook_url,
                data={"payload_json": json.dumps(payload)},
                files={"file": ("screenshot.png", file)}
            )
        if response.status_code == 204 or response.status_code == 200:
            print(Fore.GREEN + "[ Rokid Manager ] - Device information has been successfully sent to the webhook." + Style.RESET_ALL)
        else:
            print(Fore.RED + f"[ Rokid Manager ] - Error sending device information to the webhook, status code: {response.status_code}" + Style.RESET_ALL)
        time.sleep(interval * 60)

def stop_webhook():
    global stop_webhook_thread
    stop_webhook_thread = True

def setup_webhook():
    global webhook_url, device_name, interval, stop_webhook_thread
    stop_webhook_thread = True
    webhook_url = input(Fore.MAGENTA + "[ Rokid Manager ] - Please enter your Webhook URL: " + Style.RESET_ALL)
    device_name = input(Fore.MAGENTA + "[ Rokid Manager ] - Please enter your device name: " + Style.RESET_ALL)
    interval = int(input(Fore.MAGENTA + "[ Rokid Manager ] - Please enter the interval to send device information to the Webhook (in minutes): " + Style.RESET_ALL))
    save_config()
    stop_webhook_thread = False
    threading.Thread(target=send_webhook).start()

def reset_executor_file(username):
    """
    Clears any existing executor status file for the given username.
    This ensures a fresh start each time Roblox is launched, only in a valid Workspace path (lowercase or uppercase).
    """
    status_file = f"executor_check_{username}.txt"
    valid_workspace = None  # Will store the valid workspace path once detected

    # Search only in Workspace paths (uppercase 'W' and lowercase 'w')
    for executor, base_path in executors.items():
        for workspace_dir in ["workspace", "Workspace"]:
            workspace_path = os.path.join(base_path, workspace_dir)
            if os.path.exists(workspace_path):
                valid_workspace = workspace_path
                break  # Exit the loop once a valid workspace is found

        if valid_workspace:
            # Clear the status file in the detected workspace
            file_path = os.path.join(valid_workspace, status_file)
            if os.path.exists(file_path):
                try:
                    os.remove(file_path)  # Clear the status file for a fresh start
                    # The print statements have been removed as intended
                except Exception as e:
                    pass  # Ignore the error silently
            break  # Exit the executor loop once the file is removed

def clear_executor_status(username):
    """
    Clears any existing executor status file for the given username.
    This ensures a fresh start each time Roblox is launched, only in a valid Workspace path (lowercase or uppercase).
    """
    status_file = f"executor_check_{username}.txt"
    valid_workspace = None  # Will store the valid workspace path once detected

    # Search only in Workspace paths (uppercase 'W' and lowercase 'w')
    for executor, base_path in executors.items():
        for workspace_dir in ["workspace", "Workspace"]:
            workspace_path = os.path.join(base_path, workspace_dir)
            if os.path.exists(workspace_path):
                valid_workspace = workspace_path
                break  # Exit the loop once a valid workspace is found

        if valid_workspace:
            # Clear the status file in the detected workspace
            file_path = os.path.join(valid_workspace, status_file)
            if os.path.exists(file_path):
                try:
                    os.remove(file_path)  # Clear the status file for a fresh start
                    # The print statements have been removed as intended
                except Exception as e:
                    pass  # Ignore the error silently
            break  # Exit the executor loop once the file is removed
                
def check_executor_status(username, continuous=False, max_wait_time=240, check_interval=5, max_inactivity_time=30):
    status_file = f"executor_check_{username}.txt"
    retry_timeout = time.time() + max_wait_time  # Maximum time to wait before rejoining
    active_workspace = None  # Track the valid workspace path once detected

    # Dynamically search for a valid workspace (lowercase or uppercase)
    for executor, base_path in executors.items():
        for workspace_dir in ["workspace", "Workspace"]:
            workspace_path = os.path.join(base_path, workspace_dir)
            if os.path.exists(workspace_path):
                active_workspace = workspace_path
                break  # Exit the loop once a valid workspace is found

        if active_workspace:
            break  # Stop searching once we find a valid workspace

    if not active_workspace:
        # No valid workspace found; skip executor check silently
        return True  # Skip the check if no valid workspace is found

    start_time = time.time()
    
    while True:  # Continuous checking or stop after max_wait_time if continuous=False
        file_path = os.path.join(active_workspace, status_file)

        if os.path.exists(file_path):
            # Check the last modification time
            last_modified_time = os.path.getmtime(file_path)
            current_time = time.time()

            # If the file was modified within the max_inactivity_time, we assume it's still being updated
            if current_time - last_modified_time < max_inactivity_time:
                with open(file_path, 'r') as f:
                    content = f.read().strip()

                    # Check if the content starts with "working", ignore the timestamp for this check
                    if content.startswith("working"):
                        return True  # Executor loaded successfully

        # Exit after max_wait_time if continuous is False
        if not continuous and time.time() > retry_timeout:
            return False  # Trigger a rejoin or retry logic

        # Continue checking at regular intervals
        time.sleep(check_interval)  # Wait before checking again

def create_dynamic_menu(options):
    max_option_length = max(len(option) for option in options)

    top_border = f"{Fore.LIGHTCYAN_EX}x{'-' * (max_option_length + 7)}x"
    bottom_border = f"{Fore.LIGHTCYAN_EX}x{'-' * (max_option_length + 7)}x{Style.RESET_ALL}"
    
    menu_content = [f"{Fore.LIGHTCYAN_EX}| {Fore.LIGHTMAGENTA_EX}[{str(i + 1).zfill(2)}]{Fore.LIGHTCYAN_EX} {option.ljust(max_option_length)} |" 
                    for i, option in enumerate(options)]

    print(top_border)
    for line in menu_content:
        print(line)
    print(bottom_border)

def create_dynamic_table(headers, rows):
    col_widths = [max(len(str(item)) for item in col) for col in zip(headers, *rows)]

    top_border = f"{Fore.LIGHTCYAN_EX}x" + "x".join("-" * (width + 2) for width in col_widths) + "x"
    middle_border = f"{Fore.LIGHTCYAN_EX}|" + "|".join("-" * (width + 2) for width in col_widths) + "|"
    bottom_border = f"{Fore.LIGHTCYAN_EX}x" + "x".join("-" * (width + 2) for width in col_widths) + "x" + Style.RESET_ALL

    header_row = f"{Fore.LIGHTCYAN_EX}| " + " | ".join(header.center(col_widths[i]) for i, header in enumerate(headers)) + " |"
    
    data_rows = [f"{Fore.LIGHTCYAN_EX}| " + " | ".join(str(row[i]).center(col_widths[i]) for i in range(len(headers))) + " |"
                 for row in rows]

    print(top_border)
    print(header_row)
    print(middle_border)
    for row in data_rows:
        print(row)
    print(bottom_border)

def update_status_table(package_statuses):
    clear_screen()
    print_header()

    headers = ["Package", "Username", "Status"]
    status_width = 30  
    
    col_widths = [
        max(len(headers[0]), max(len(str(package)) for package in package_statuses.keys())) + 2,
        max(len(headers[1]), max(len(str(info.get("Username", "Unknown"))) for info in package_statuses.values())) + 2,
        status_width  
    ]
    
    top_border = f"{Fore.LIGHTCYAN_EX}x" + "x".join("-" * width for width in col_widths) + "x"
    middle_border = f"{Fore.LIGHTCYAN_EX}x" + "x".join("-" * width for width in col_widths) + "x"
    bottom_border = f"{Fore.LIGHTCYAN_EX}x" + "x".join("-" * width for width in col_widths) + "x" + Style.RESET_ALL

    header_row = f"{Fore.LIGHTCYAN_EX}|" + "|".join(header.center(col_widths[i]) for i, header in enumerate(headers)) + "|"
    
    data_rows = []
    for package, info in package_statuses.items():
        row = [
            str(package).ljust(col_widths[0]),
            str(info.get("Username", "Unknown")).ljust(col_widths[1]),
            str(info.get("Status", "")).ljust(col_widths[2])  
        ]
        data_rows.append(f"{Fore.LIGHTCYAN_EX}|" + "|".join(row) + "|")
    
    print(top_border)
    print(header_row)
    print(middle_border)
    for row in data_rows:
        print(row)
    print(bottom_border)
        
def verify_cookie(cookie_value):
    try:
        headers = {
            'Cookie': f'.ROBLOSECURITY={cookie_value}',
            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; Mobile) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Mobile Safari/537.36',
            'Referer': 'https://www.roblox.com/',
            'Origin': 'https://www.roblox.com',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive'
        }

        time.sleep(1)

        response = requests.get('https://users.roblox.com/v1/users/authenticated', headers=headers)

        if response.status_code == 200:
            print(Fore.GREEN + "Cookie is valid! User is authenticated." + Style.RESET_ALL)
            return True
        elif response.status_code == 401:
            print(Fore.RED + "Invalid cookie. The user is not authenticated." + Style.RESET_ALL)
            return False
        else:
            print(Fore.RED + f"Error verifying cookie: {response.status_code} - {response.text}" + Style.RESET_ALL)
            return False

    except Exception as e:
        print(Fore.RED + f"Exception occurred while verifying cookie: {e}" + Style.RESET_ALL)
        return False
        
def download_file(url, destination, binary=False):
    try:
        response = requests.get(url, stream=True)
        if response.status_code == 200:
            mode = 'wb' if binary else 'w'
            with open(destination, mode) as file:
                if binary:
                    shutil.copyfileobj(response.raw, file)
                else:
                    file.write(response.text)
            print(Fore.GREEN + f"{os.path.basename(destination)} downloaded successfully." + Style.RESET_ALL)
            return destination
        else:
            print(Fore.RED + f"Failed to download {os.path.basename(destination)}." + Style.RESET_ALL)
            return None
    except Exception as e:
        print(Fore.RED + f"Error downloading {os.path.basename(destination)}: {e}" + Style.RESET_ALL)
        return None

def replace_cookie_value_in_db(db_path, new_cookie_value):
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        cursor.execute("""
            SELECT COUNT(*) FROM cookies WHERE host_key = '.roblox.com' AND name = '.ROBLOSECURITY'
        """)
        cookie_exists = cursor.fetchone()[0]

        if cookie_exists:
            cursor.execute("""
                UPDATE cookies
                SET value = ?, last_access_utc = ?, expires_utc = ?
                WHERE host_key = '.roblox.com' AND name = '.ROBLOSECURITY'
            """, (new_cookie_value, int(time.time() * 1000000), 99999999999999999))
        else:
            cursor.execute("""
                INSERT INTO cookies (creation_utc, host_key, name, value, path, expires_utc, is_secure, is_httponly, last_access_utc)
                VALUES (?, '.roblox.com', '.ROBLOSECURITY', ?, '/', 99999999999999999, 0, 0, ?)
            """, (int(time.time() * 1000000), new_cookie_value, int(time.time() * 1000000)))

        conn.commit()
        conn.close()
        print(Fore.GREEN + "Cookie value replaced successfully in the database!" + Style.RESET_ALL)

    except sqlite3.OperationalError as e:
        print(Fore.RED + f"Database error during cookie replacement: {e}" + Style.RESET_ALL)
    except Exception as e:
        print(Fore.RED + f"Error replacing cookie value in database: {e}" + Style.RESET_ALL)

def inject_cookies_and_appstorage():
    db_url = "https://github.com/shirooscripts/auto-rj/raw/main/Cookies"  # Keep this as binary
    appstorage_url = "https://raw.githubusercontent.com/shirooscripts/auto-rj/main/appStorage.json"  # Use this for JSON

    downloaded_db_path = download_file(db_url, "Cookies.db", binary=True)
    downloaded_appstorage_path = download_file(appstorage_url, "appStorage.json", binary=False)

    if not downloaded_db_path or not downloaded_appstorage_path:
        print(Fore.RED + "Failed to download necessary files. Exiting." + Style.RESET_ALL)
        return
    
    cookie_txt_path = os.path.join(os.getcwd(), "cookie.txt")  

    if not os.path.exists(cookie_txt_path):
        print(Fore.RED + "cookie.txt not found in the current directory!" + Style.RESET_ALL)
        return

    with open(cookie_txt_path, "r") as file:
        cookies = [line.strip() for line in file.readlines()]

    if not cookies:
        print(Fore.RED + "No cookies found in cookie.txt. Please add your cookies." + Style.RESET_ALL)
        return

    packages = get_roblox_packages()

    if len(cookies) > len(packages):
        print(Fore.RED + "More cookies in cookie.txt than packages available. Please ensure each cookie has a corresponding package." + Style.RESET_ALL)
        return

    for idx, package_name in enumerate(packages):
        try:
            cookie = cookies[idx]  
            if cookie.count(":") >= 2:  
                parts = cookie.split(":")
                username = parts[0]
                password = parts[1]
                cookie = ":".join(parts[2:])  

                print(Fore.YELLOW + f"Verifying cookie for {package_name} before injection..." + Style.RESET_ALL)
                if verify_cookie(cookie):
                    print(Fore.GREEN + f"Cookie for {package_name} is valid!" + Style.RESET_ALL)
                else:
                    print(Fore.RED + f"Cookie for {package_name} is invalid. Skipping injection..." + Style.RESET_ALL)
                    continue

                print(Fore.GREEN + f"Injecting cookie for {package_name}: {cookie}" + Style.RESET_ALL)

                destination_db_dir = f"/data/data/{package_name}/app_webview/Default/"
                destination_appstorage_dir = f"/data/data/{package_name}/files/appData/LocalStorage/"

                os.makedirs(destination_db_dir, exist_ok=True)
                os.makedirs(destination_appstorage_dir, exist_ok=True)

                destination_db_path = os.path.join(destination_db_dir, "Cookies")
                shutil.copyfile(downloaded_db_path, destination_db_path)
                print(Fore.GREEN + f"Copied Cookies.db to {destination_db_path}" + Style.RESET_ALL)

                destination_appstorage_path = os.path.join(destination_appstorage_dir, "appStorage.json")
                shutil.copyfile(downloaded_appstorage_path, destination_appstorage_path)
                print(Fore.GREEN + f"Copied appStorage.json to {destination_appstorage_path}" + Style.RESET_ALL)

                replace_cookie_value_in_db(destination_db_path, cookie)

                print(Fore.YELLOW + f"Verifying cookie for {package_name} after injection..." + Style.RESET_ALL)
                if verify_cookie(cookie):
                    print(Fore.GREEN + f"Cookie for {package_name} is valid after injection!" + Style.RESET_ALL)
                else:
                    print(Fore.RED + f"Cookie for {package_name} is invalid after injection!" + Style.RESET_ALL)

        except Exception as e:
            print(Fore.RED + f"Error injecting cookie for {package_name}: {e}" + Style.RESET_ALL)

    print(Fore.GREEN + "Cookie and appStorage injection completed for all packages." + Style.RESET_ALL)

def get_roblox_packages():
    packages = []
    suffixes = 'qwertyuiopasdfghjklzxcvbnm0123456789'
    
    try:
        output = subprocess.check_output("pm list packages", shell=True, text=True)
    except subprocess.CalledProcessError as e:
        print(Fore.RED + "An Error Occurred While Searching For Package On Your Device!" + Style.RESET_ALL)
        return packages

    for suffix in suffixes:
        package_name = f"com.roblox.clien{suffix}"
        print(Fore.YELLOW + f"Checking Packages On Your Device: {package_name}" + Style.RESET_ALL)
        
        if package_name in output:
            print(Fore.GREEN + f"Package Found On Your Device Is: {package_name}" + Style.RESET_ALL)
            packages.append(package_name)

    return packages

def is_roblox_running(package_name):
    for proc in psutil.process_iter(['name']):
        if package_name in proc.info['name'].lower():
            return True
    return False

# Function to kill Roblox processes
def kill_roblox_processes():
    print("Killing all Roblox processes...")
    package_names = get_roblox_packages()
    for package_name in package_names:
        print(f"Trying to kill process for package: {package_name}")
        # Use pkill to kill processes by package name
        os.system(f"pkill -f {package_name}")
    time.sleep(2) 

# Function to kill a specific Roblox process
def kill_roblox_process(package_name):
    print(f"Killing Roblox process for {package_name}...")
    # Use pkill to kill process by package name
    os.system(f"pkill -f {package_name}")
    time.sleep(2) 

# Function to launch Roblox
def launch_roblox(package_name, server_link, num_packages, package_statuses):
    try:
        # Update the status to indicate Roblox is opening
        package_statuses[package_name]["Status"] = Fore.LIGHTCYAN_EX + f"Opening Roblox for {package_name}..." + Style.RESET_ALL
        update_status_table(package_statuses)

        # Open Roblox (Initial Splash)
        subprocess.run(['am', 'start', '-n', f'{package_name}/com.roblox.client.startup.ActivitySplash', '-d', server_link], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time.sleep(15 if num_packages >= 6 else 8)  # Adjust wait time based on the number of packages

        # Proceed to launch
        package_statuses[package_name]["Status"] = Fore.LIGHTCYAN_EX + f"Joining Roblox for {package_name}..." + Style.RESET_ALL
        update_status_table(package_statuses)
        subprocess.run(['am', 'start', '-n', f'{package_name}/com.roblox.client.ActivityProtocolLaunch', '-d', server_link], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # Wait a moment to ensure Roblox has launched
        time.sleep(20)
        
        # Update the status after successful join
        package_statuses[package_name]["Status"] = Fore.GREEN + "Joined Roblox" + Style.RESET_ALL
        update_status_table(package_statuses)

    except Exception as e:
        # Catch all exceptions and log them specifically to avoid "launching failed" messages
        package_statuses[package_name]["Status"] = Fore.RED + f"Error launching Roblox for {package_name}: {e}" + Style.RESET_ALL
        update_status_table(package_statuses)
        print(f"Error details: {e}")

def check_executor_and_rejoin(package_name, username, package_statuses, server_link, num_packages, accounts):
    try:
        # Inject Lua script for executor detection (the username is auto-detected in the Lua script)
        detected_executors = detect_and_write_lua_script()

        if detected_executors:
            print(f"Checking executor status for {package_name} with username {username}...")

            # Keep checking for the executor status, up to 2 minutes (every 10 seconds)
            start_time = time.time()
            executor_loaded = False
            while time.time() - start_time < 120:  # 2 minutes timeout
                if check_executor_status(username):
                    package_statuses[package_name]["Status"] = Fore.GREEN + f"Executor loaded successfully for {username}" + Style.RESET_ALL
                    executor_loaded = True
                    break
                time.sleep(10)

            # If executor didn't load within the timeout, rejoin
            if not executor_loaded:
                print(f"Executor did not load for {package_name} (username: {username}). Rejoining...")
                package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                update_status_table(package_statuses)

                # Rejoin by killing the current Roblox process and relaunching
                kill_roblox_process(package_name)
                time.sleep(2)
                launch_roblox(package_name, server_link, num_packages, package_statuses)
                check_executor_and_rejoin(package_name, username, package_statuses, server_link, num_packages, accounts)
        else:
            # No executor was detected; proceed without rejoining
            print(f"No executor detected for {package_name} (username: {username}).")
            package_statuses[package_name]["Status"] = Fore.GREEN + f"Joined without executor for {username}" + Style.RESET_ALL
            update_status_table(package_statuses)

        # Start the background executor monitor after joining
        monitor_thread = threading.Thread(target=background_executor_monitor, args=(package_name, username, package_statuses, server_link, num_packages))
        monitor_thread.daemon = True  # Ensures the thread closes when the main program exits
        monitor_thread.start()

    except Exception as e:
        package_statuses[package_name]["Status"] = Fore.RED + f"Error checking executor for {package_name}: {e}" + Style.RESET_ALL
        update_status_table(package_statuses)

def background_executor_monitor(package_name, username, package_statuses, server_link, num_packages, retry_limit=3):
    retry_count = 0

    try:
        while True:
            # Periodically check the executor status every 10 seconds
            if not check_executor_status(username, continuous=False):
                # Increment retry count
                retry_count += 1
                package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                update_status_table(package_statuses)
                
                # Check if retry limit reached to prevent endless rejoining
                if retry_count >= retry_limit:
                    package_statuses[package_name]["Status"] = Fore.RED + "Reached retry limit, stopping rejoin attempts..." + Style.RESET_ALL
                    update_status_table(package_statuses)
                    break

                # Acquire lock to ensure only one Roblox process is relaunched at a time
                with rejoin_lock:
                    # Rejoin by killing the current Roblox process and relaunching
                    kill_roblox_process(package_name)
                    time.sleep(5)  # Grace period before relaunching
                    launch_roblox(package_name, server_link, num_packages, package_statuses)
                    
                    # Wait another 30 seconds before checking executor status after relaunch
                    time.sleep(120)

                # Check the executor status again after relaunch
                if check_executor_status(username, continuous=False):
                    # Reset retry count if executor successfully loaded
                    retry_count = 0
                    package_statuses[package_name]["Status"] = Fore.GREEN + "Executor reloaded successfully after rejoin." + Style.RESET_ALL
                    update_status_table(package_statuses)
                else:
                    package_statuses[package_name]["Status"] = Fore.RED + "Executor still failed after rejoin, retrying..." + Style.RESET_ALL
                    update_status_table(package_statuses)

            # Wait before the next check
            time.sleep(30)
    except Exception as e:
        package_statuses[package_name]["Status"] = Fore.RED + f"Error in background monitor: {e}" + Style.RESET_ALL
        update_status_table(package_statuses)
        
def get_game_name(game_link_or_id):
    try:
        # Extract the game ID from the link if it's a URL
        if 'roblox.com' in game_link_or_id:
            game_id = game_link_or_id.split('/')[-1]
        else:
            game_id = game_link_or_id

        # Make a request to the Roblox API to get game details
        url = f"https://games.roblox.com/v1/games?universeIds={game_id}"
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            game_data = response.json()
            if game_data['data']:
                return game_data['data'][0]['name']
            else:
                return "Unknown Game"
        else:
            return "Failed to retrieve game name"
    except Exception as e:
        print(Fore.RED + f"Error retrieving game name: {e}" + Style.RESET_ALL)
        return "Error"
        
# Function to format server link
def format_server_link(input_link):
    if 'roblox.com' in input_link:
        return input_link
    elif input_link.isdigit():
        return f'roblox://placeID={input_link}'
    else:
        print(Fore.RED + "Invalid input! Please enter a valid game ID or private server link." + Style.RESET_ALL)
        return None

# Function to save server links to file
def save_server_links(server_links):
    with open(SERVER_LINKS_FILE, "w") as file:
        for package, link in server_links:
            file.write(f"{package},{link}\n")

# Function to load server links from file
def load_server_links():
    server_links = []
    if os.path.exists(SERVER_LINKS_FILE):
        with open(SERVER_LINKS_FILE, "r") as file:
            for line in file:
                package, link = line.strip().split(",", 1)
                server_links.append((package, link))
    return server_links

# Function to save accounts to file
def save_accounts(accounts):
    with open(ACCOUNTS_FILE, "w") as file:
        for package, user_id in accounts:
            file.write(f"{package},{user_id}\n")

def load_accounts():
    accounts = []
    if os.path.exists(ACCOUNTS_FILE):
        with open(ACCOUNTS_FILE, "r") as file:
            for line in file:
                line = line.strip()  
                if line:  
                    try:
                        package, user_id = line.split(",", 1)  
                        accounts.append((package, user_id))  
                    except ValueError:
                        print(f"{Fore.RED}Invalid line format: {line}. Expected format 'package,user_id'.{Style.RESET_ALL}")
    return accounts

# Function to find UserId from file
def find_userid_from_file(file_path):
    try:
        with open(file_path, 'r') as file:
            content = file.read()
            # Debugging information removed to keep console clean

            userid_start = content.find('"UserId":"')
            if userid_start == -1:
                print("Userid not found")
                return None

            userid_start += len('"UserId":"')
            userid_end = content.find('"', userid_start)
            if userid_end == -1:
                print("Userid end quote not found")
                return None

            userid = content[userid_start:userid_end]
            return userid

    except IOError as e:
        print(f"Error reading file: {e}")
        return None

# Asynchronous function to get user ID from username
async def get_user_id(username):
    url = "https://users.roblox.com/v1/usernames/users"
    payload = {
        "usernames": [username],
        "excludeBannedUsers": True
    }
    headers = {
        "Content-Type": "application/json"
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=payload, headers=headers) as response:
            data = await response.json()
            if 'data' in data and len(data['data']) > 0:
                return data['data'][0]['id']
    return None

def get_server_link(package_name, server_links):
    return next((link for pkg, link in server_links if pkg == package_name), None)

def get_username_from_id(user_id):
    return get_username(user_id) or user_id
    
# Function to get username from user ID
def get_username(user_id):
    retry_attempts = 2
    for attempt in range(retry_attempts):
        try:
            url = f"https://users.roblox.com/v1/users/{user_id}"
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            username = data.get("name", "Unknown")
            if username != "Unknown":
                username_cache[user_id] = username
                save_username(user_id, username)
                return username
        except requests.exceptions.RequestException as e:
            print(Fore.RED + f"Attempt {attempt + 1} failed for Roblox Users API: {e}" + Style.RESET_ALL)
            time.sleep(2 ** attempt)  # Exponential backoff

    # Fallback to RoProxy API
    for attempt in range(retry_attempts):
        try:
            url = f"https://users.roproxy.com/v1/users/{user_id}"
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            username = data.get("name", "Unknown")
            if username != "Unknown":
                username_cache[user_id] = username
                save_username(user_id, username)
                return username
        except requests.exceptions.RequestException as e:
            print(Fore.RED + f"Attempt {attempt + 1} failed for RoProxy API: {e}" + Style.RESET_ALL)
            time.sleep(2 ** attempt)  # Exponential backoff

    return "Unknown"

# Example of saving the username in a persistent storage
def save_username(user_id, username):
    try:
        if not os.path.exists("usernames.json"):
            with open("usernames.json", "w") as file:
                json.dump({user_id: username}, file)
        else:
            with open("usernames.json", "r+") as file:
                try:
                    data = json.load(file)
                except json.JSONDecodeError:
                    data = {}
                data[user_id] = username
                file.seek(0)
                json.dump(data, file)
                file.truncate()
    except (IOError, json.JSONDecodeError) as e:
        print(Fore.RED + f"Error saving username: {e}" + Style.RESET_ALL)

# Example of loading the username from persistent storage
def load_saved_username(user_id):
    try:
        with open("usernames.json", "r") as file:
            data = json.load(file)
            return data.get(user_id)
    except (FileNotFoundError, json.JSONDecodeError, IOError) as e:
        print(Fore.RED + f"Error loading username: {e}" + Style.RESET_ALL)
        return None
    
def load_cache():
    global username_cache
    if os.path.exists(CACHE_FILE):
        with open(CACHE_FILE, "r") as f:
            username_cache = json.load(f)

# Save the cache to file
def save_cache():
    try:
        temp_file = CACHE_FILE + ".tmp"
        with open(temp_file, "w") as f:
            json.dump(username_cache, f)
        os.replace(temp_file, CACHE_FILE)  # Atomic move to replace the file
    except IOError as e:
        print(Fore.RED + f"Error saving cache: {e}" + Style.RESET_ALL)
        
def check_user_online(user_id):
    max_retries = 3
    delay = 2

    for attempt in range(max_retries):
        try:
            primary_url = "https://presence.roblox.com/v1/presence/users"
            headers = {'Content-Type': 'application/json'}
            body = json.dumps({"userIds": [user_id]})
            with requests.Session() as session:
                primary_response = session.post(primary_url, headers=headers, data=body, timeout=7)
            primary_response.raise_for_status()
            primary_data = primary_response.json()
            primary_presence_type = primary_data["userPresences"][0]["userPresenceType"]
            primary_last_location = primary_data["userPresences"][0].get("lastLocation", None)

            if primary_last_location == "Website":
                print(Fore.YELLOW + f"{user_id} is currently on the Website. Rejoin recommended." + Style.RESET_ALL)
                primary_presence_type = 0  # Set presence type to offline to trigger a rejoin

            return primary_presence_type, primary_last_location

        except requests.exceptions.RequestException as e:
            print(Fore.RED + f"Error checking online status for user {user_id} (Attempt {attempt + 1}): {e}" + Style.RESET_ALL)
            if attempt < max_retries - 1:
                time.sleep(delay)
                delay *= 2  # Exponential backoff
            else:
                return None, None

def get_hwid_file_path(package_name):
    # Specify the directory
    directory = f"/data/data/{package_name}/app_assets/content/"
    
    try:
        # List all files in the directory, excluding directories
        files = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]

        if not files:
            print(Fore.RED + "No files found in the specified directory." + Style.RESET_ALL)
            return None

        # Get the last file based on its natural order in the directory
        last_file = files[-1]
        hwid_file_path = os.path.join(directory, last_file)

        return hwid_file_path
            
    except Exception as e:
        print(Fore.RED + f"Error retrieving HWID file path: {e}" + Style.RESET_ALL)
        return None
        
# Function to get HWID for Fluxus
def get_hwid(package_name):
    # Specify the directory
    directory = f"/data/data/{package_name}/app_assets/content/"
    
    try:
        # List all files in the directory, excluding directories
        files = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]

        if not files:
            print(Fore.RED + "No files found in the specified directory." + Style.RESET_ALL)
            return None

        # Get the last file based on its natural order in the directory
        last_file = files[-1]
        hwid_file_path = os.path.join(directory, last_file)

        # Read the HWID from the file
        with open(hwid_file_path, "r") as file:
            hwid = file.read().strip()
            print(Fore.GREEN + f"HWID found: {hwid}" + Style.RESET_ALL)
            return hwid
            
    except Exception as e:
        print(Fore.RED + f"Error retrieving HWID: {e}" + Style.RESET_ALL)
        return None

def get_hwid_platoboost():
	hwid = ""
	if os.path.exists("hwid_platoboost.txt"):
		with open("hwid_platoboost.txt", "r") as f:
			hwid = f.read().strip()
			f.close()
	if hwid == "" or hwid == None:
		url = input("Enter link platoboost you want to bypass: ")
		a = parse_qs(urlparse(url).query).get("id", [None])[0]
		if a is None:
			hwid = url
		else:
			hwid = a
		with open("hwid_platoboost.txt", "w") as f:
			f.write(hwid)
			f.close()
	return hwid

# Function to create bypass link for Fluxus
def create_fluxus_bypass_link(hwid, api_key="XqzyaenZishd33axPYPz"):
    return f"https://madkung.vercel.app/fluxus-api?url=https://flux.li/android/external/start.php?HWID={hwid}&api_key={api_key}"

def create_bypass_link(api, hwid):
	head_option = {
		"Host": "api-gateway.platoboost.com",
		"accept": "*/*",
		"access-control-request-method": "GET",
		"access-control-request-headers": "version",
		"origin": "https://gateway.platoboost.com",
		"user-agent": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Mobile Safari/537.36",
		"sec-fetch-mode": "cors",
		"sec-fetch-site": "same-site",
		"sec-fetch-dest": "empty",
		"referer": "https://gateway.platoboost.com/",
		"accept-language": "vi-VN,vi;q=0.9,fr-FR;q=0.8,fr;q=0.7,en-US;q=0.6,en;q=0.5",
		"priority": "u=1, i"
	}

	header = {
		"Host": "api-gateway.platoboost.com",
		"sec-ch-ua": "\"Not)A;Brand\";v=\"99\", \"Google Chrome\";v=\"127\", \"Chromium\";v=\"127\"",
		"accept": "application/json",
		"content-type": "application/json",
		"sec-ch-ua-platform": "\"Android\"",
		"dnt": "1",
		"sec-ch-ua-mobile": "?1",
		"user-agent": "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Mobile Safari/537.36",
		"version": "3.3.5",
		"origin": "https://gateway.platoboost.com",
		"sec-fetch-site": "same-site",
		"sec-fetch-mode": "cors",
		"sec-fetch-dest": "empty",
		"referer": "https://gateway.platoboost.com/",
		"accept-language": "vi-VN,vi;q=0.9,fr-FR;q=0.8,fr;q=0.7,en-US;q=0.6,en;q=0.5",
		"priority": "u=1, i"
	}

	session = requests.Session()

	data = {
		"captcha": "",
		"type":""
	}

	try:
		session.options(f"https://api-gateway.platoboost.com/v1/authenticators/{api}/{hwid}", headers=head_option, timeout=5)
		rokid_manager = session.get(f"https://api-gateway.platoboost.com/v1/authenticators/{api}/{hwid}", headers=header, timeout=5).json()
		if rokid_manager.get("key", False):
			t = rokid_manager.get("minutesLeft", 0)
			return {"key": rokid_manager.get("key"), "timeleft": t*60}
		checkpointCount = rokid_manager.get("checkpointCount", 0)
		captcha = rokid_manager.get("captcha", False)
		if captcha:
			return {"error": "Can't bypass human security check!"}
		head_option["access-control-request-method"] = "POST"
		head_option["access-control-request-headers"] = "content-type,version"
		session.options(f"https://api-gateway.platoboost.com/v1/sessions/auth/{api}/{hwid}", headers=head_option, timeout=5)
		rokid_manager = session.post(f"https://api-gateway.platoboost.com/v1/sessions/auth/{api}/{hwid}", headers=header, json=data, timeout=5).json()
		for i in range(checkpointCount):
			if rokid_manager.get("redirect", False):
				r = parse_qs(urlparse(rokid_manager.get("redirect")).query)["r"][0]
				url = str(base64.b64decode(r).decode("utf-8"))
				tk = parse_qs(urlparse(url).query)["tk"][0]
				time.sleep(5)
				head_option["access-control-request-method"] = "GET"
				head_option["access-control-request-headers"] = "version"
				session.options(f"https://api-gateway.platoboost.com/v1/sessions/auth/{api}/{hwid}", headers=head_option, timeout=5)
				session.get("https://api-gateway.platoboost.com/v1/sessions/auth/{api}/{hwid}", headers=header, timeout=5)
				head_option["access-control-request-method"] = "PUT"
				session.options(f"https://api-gateway.platoboost.com/v1/sessions/auth/{api}/{hwid}/{tk}", headers=head_option, timeout=5)
				rokid_manager = session.put(f"https://api-gateway.platoboost.com/v1/sessions/auth/{api}/{hwid}/{tk}", headers=header, timeout=5).json()
			else:
				return {"error": rokid_manager.get("message", "Lỗi không xác định")}
		if "gateway.platoboost.com" in rokid_manager.get("redirect", False):
			head_option["access-control-request-method"] = "GET"
			session.options(f"https://api-gateway.platoboost.com/v1/authenticators/{api}/{hwid}", headers=head_option, timeout=5)
			rokid_manager = session.get(f"https://api-gateway.platoboost.com/v1/authenticators/{api}/{hwid}", headers=header, timeout=5).json()
			t = rokid_manager.get("minutesLeft", 0)
			return {"key": rokid_manager.get("key"), "timeleft": t*60+60}
		else:
			return {"error": "Can't bypass Delta!"}
	except Exception as e:
		return {"error": "Something went wrong!"}

def decrement_time(time_str):
    hours, minutes = map(int, time_str.replace('H', '').replace('M', '').split())
    
    if minutes > 0:
        minutes -= 1
    elif hours > 0:
        hours -= 1
        minutes = 59
    else:
        # If it's already "0H 0M", it stays the same
        return "0H 0M"
    
    return f"{hours}H {minutes}M"

def bypass_user_ids(accounts, executor_choice, minutes_left_dict=None):
    bypassed_results = []

    for package_name, _ in accounts:  # We don't need user_id_or_name anymore
        username = package_name  # Assuming package_name is used as the username for display

        try:
            if executor_choice == "1":  # Delta bypass
                # Get HWID
                hwid = get_hwid_platoboost()  # Directly get HWID from the function
                if hwid:
                    bypass_link = create_bypass_link(package_name, hwid)  # Use package_name as the API
                    try:
                        response = requests.get(bypass_link)
                        if response.status_code == 200:
                            result = response.json()
                            minutes_left = result.get('minutesLeft', '0H 0M')
                            if minutes_left_dict is not None:
                                minutes_left_dict[package_name] = minutes_left  # Store the minutes_left value
                            bypassed_results.append((package_name, result))
                            print(Fore.GREEN + f"{username}: Bypass successful with HWID - {result}" + Style.RESET_ALL)
                        else:
                            print(Fore.RED + f"{username}: Bypass failed with status code {response.status_code} using HWID" + Style.RESET_ALL)
                    except Exception as e:
                        print(Fore.RED + f"{username}: Error using HWID - {str(e)}" + Style.RESET_ALL)

            elif executor_choice == "2":  # Fluxus bypass
                hwid = get_hwid(package_name)  # Assuming get_hwid still exists for Fluxus
                if hwid:
                    bypass_link = create_fluxus_bypass_link(hwid)
                    try:
                        response = requests.get(bypass_link)
                        if response.status_code == 200:
                            bypassed_results.append((package_name, response.json()))
                            print(Fore.GREEN + f"{username}: Fluxus Bypass successful - {response.json()}" + Style.RESET_ALL)
                        else:
                            print(Fore.RED + f"{username}: Fluxus Bypass failed with status code {response.status_code}" + Style.RESET_ALL)
                    except Exception as e:
                        print(Fore.RED + f"{username}: Error during Fluxus Bypass - {str(e)}" + Style.RESET_ALL)
                else:
                    print(Fore.RED + f"{username}: Failed to retrieve HWID for Fluxus" + Style.RESET_ALL)

        except Exception as bypass_error:
            print(Fore.RED + f"Error during bypass for {package_name}: {bypass_error}" + Style.RESET_ALL)
            continue

    return bypassed_results

detect_and_write_lua_script()

def read_roblox_data(data_path, retries=3):
    attempt = 0
    while attempt < retries:
        try:
            with open(data_path, 'r') as file:
                data = json.load(file)
                user_id = data.get("UserId")
                username = data.get("Username")
                if user_id is not None and username is not None:
                    return user_id, username
                else:
                    attempt += 1
        except Exception as e:
            attempt += 1
            time.sleep(1) 

    return False, False

def find_roblox_data_paths():
    base_path = "/data/data"
    paths = []
    for folder in os.listdir(base_path):
        if folder.startswith("com.roblox.") and folder != 'com.roblox.client':
            path = os.path.join(base_path, folder, "files/appData/LocalStorage/appStorage.json")
            if os.path.isfile(path):
                paths.append(path)
    return paths

def logout_account(userid, username, data_path):
    try:
        roblox_package = data_path.split(os.sep)[3]
        force_roblox(roblox_package)
        appstorage_path = os.path.join(data_path)
        print(f"Logging out account: {username}, path: {appstorage_path}")
        os.remove(appstorage_path)
        logged_in_usernames.remove(username)
        print(f"Logged out account: {username}")
    except Exception as e:
        print(f"Logged out account: {username}")

def force_roblox(packages):
    try:
        full_command = f"pkill -f {packages}"
        subprocess.run(
            full_command,
            check=True,
            timeout=10,
            shell=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
    except subprocess.TimeoutExpired:
        pass
    except subprocess.CalledProcessError as e:
        pass
    time.sleep(1)

def logout_roblox():
    global logged_in_usernames
    roblox_paths = find_roblox_data_paths()
    
    if not roblox_paths:
        print("No Roblox accounts found.")
        return

    accounts = []
    print("Available Roblox accounts:")
    for i, data_path in enumerate(roblox_paths, start=1):
        userid, username = read_roblox_data(data_path)
        if userid and username:
            accounts.append((userid, username, data_path))
            print(f"{i}. Username: {username}, UserId: {userid}")

    if not accounts:
        print("No Roblox accounts found.")
        return

    print("Enter the number of the account to log out, '0' to log out all accounts, or 'q' to quit:")
    choice = input().strip()

    if choice.lower() == 'q':
        return

    try:
        if choice == '0':
            for userid, username, data_path in accounts:
                logout_account(userid, username, data_path)
        else:
            choice_index = int(choice) - 1
            if 0 <= choice_index < len(accounts):
                userid, username, data_path = accounts[choice_index]
                logout_account(userid, username, data_path)
            else:
                print("Invalid choice. Choice index out of range.")
    except ValueError:
        print("Invalid input. Please enter a number.")
    except Exception as e:
        import traceback
        traceback.print_exc()
        print(f"Error: {e}")

logged_in_usernames = set()

def press_enter_to_continue():
    input(f"{Fore.LIGHTBLUE_EX}\nPress Enter to continue...")
    clear_console()

def print_banner():
    print(Fore.LIGHTBLACK_EX + """
  _____       _    _     _   __  __                                   
 |  __ \     | |  (_)   | | |  \/  |                                  
 | |__) |___ | | ___  __| | | \  / | __ _ _ __   __ _  __ _  ___ _ __ 
 |  _  // _ \| |/ / |/ _` | | |\/| |/ _` | '_ \ / _` |/ _` |/ _ \ '__|
 | | \ \ (_) |   <| | (_| | | |  | | (_| | | | | (_| | (_| |  __/ |   
 |_|  \_\___/|_|\_\_|\__,_| |_|  |_|\__,_|_| |_|\__,_|\__, |\___|_|   
                                                       __/ |          
                                                      |___/   
                Version : 1.0.2 -- https://discord.gg/HgSePhP3E5                       
-------------------------------------------------------------------------
    """)

def check_cookie_validity(cookie):
    url = "https://users.roblox.com/v1/users/authenticated"
    headers = {
        "Cookie": f".ROBLOSECURITY={cookie}",
        "User-Agent": "Mozilla/5.0",
        "Content-Type": "application/json"
    }
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        print(f"{Fore.GREEN}Cookie is alive!")
        user_data = response.json()
        print(f"Logged in as: {user_data['name']} (User ID: {user_data['id']})")
        return True
    elif response.status_code == 401:
        print(f"{Fore.RED}Cookie is dead or invalid!")
        return False
    else:
        print(f"{Fore.YELLOW}Unexpected response. Status Code: {response.status_code}")
        print(f"Response: {response.text}")
        return False

def check_cookies_from_file(file_path):
    folder_name = "Cookies Checked"
    if not os.path.exists(folder_name):
        os.makedirs(folder_name)
    
    live_file_path = os.path.join(folder_name, 'live.txt')
    dead_file_path = os.path.join(folder_name, 'dead.txt')
    
    if not os.path.exists(file_path):
        print(f"{Fore.RED}File {file_path} doesn't exist. Creating one...")
        with open(file_path, 'w') as file:
            file.write("") 
        print(f"{Fore.GREEN}Created {file_path}. Add cookies in it with 'username:password:cookie' format and try again!")
        return
    
    with open(file_path, 'r') as file:
        credentials = file.readlines()

    open(live_file_path, 'w').close()  # Clear live.txt
    open(dead_file_path, 'w').close()  # Clear dead.txt
    
    total_cookies = len(credentials)
    live_cookies = 0
    dead_cookies = 0
    
    for idx, cred in enumerate(credentials, 1):
        cred = cred.strip()
        if cred.count(":") >= 2:  
            parts = cred.split(":")
            username = parts[0]
            password = parts[1]
            cookie = ":".join(parts[2:])  
            
            print(f"{Fore.LIGHTBLACK_EX}Checking cookie {idx} for {username}...")
            
            if check_cookie_validity(cookie):  
                live_cookies += 1
                with open(live_file_path, 'a') as live_file:
                    live_file.write(f"{username}:{password}:{cookie}\n")
            else:  
                dead_cookies += 1
                with open(dead_file_path, 'a') as dead_file:
                    dead_file.write(f"{username}:{password}:{cookie}\n")
        else:
            print(f"{Fore.RED}Invalid format in line {idx}. Expected format 'username:password:cookie'.")
    
    print(f"--------------------------------------------------")
    print(f"\n{Fore.CYAN}Total Cookies: {total_cookies}")
    print(f"{Fore.GREEN}Live Cookies: {live_cookies}")
    print(f"{Fore.RED}Dead Cookies: {dead_cookies}")

def create_autoexc_folder():
    downloads_path = "/sdcard/download"
    autoexc_folder = os.path.join(downloads_path, "Autoexc")

    if not os.path.exists(autoexc_folder):
        print(f"Creating folder: {autoexc_folder}")
        os.makedirs(autoexc_folder)
    else:
        print(f"'Autoexc' folder already exists: {autoexc_folder}")

    return autoexc_folder

def push_autoexc_files():
    autoexc_folder = create_autoexc_folder()

    # Executor directories to push files into
    executors = {
        "Fluxus": "/storage/emulated/0/Fluxus/Autoexec",
        "Codex": "/storage/emulated/0/Codex/Autoexec",
        "Arceus X": "/storage/emulated/0/Arceus X/Autoexec",
        "Delta": "/storage/emulated/0/Delta/Autoexec",
        "Cryptic": "/storage/emulated/0/Cryptic/Autoexec"
    }

    txt_files = [f for f in os.listdir(autoexc_folder) if f.endswith('.txt')]

    if not txt_files:
        print(f"No .txt files found in {autoexc_folder}.")
        return

    for executor_name, executor_path in executors.items():
        # Only proceed if the executor path exists
        if os.path.exists(executor_path):
            for txt_file in txt_files:
                file_path = os.path.join(autoexc_folder, txt_file)
                destination = os.path.join(executor_path, txt_file)
                try:
                    shutil.copy(file_path, destination)
                    print(Fore.GREEN + f"[ Rokid Manager ] -> Pushed your scripts to {executor_name}: {destination}")
                except Exception as e:
                    print(Fore.RED + f"[ Rokid Manager ] -> Failed to push your scripts to {executor_name}: {e}")

SUCCESS_COLOR = '\x1b[92m'
FAILURE_COLOR = '\x1b[91m'
RESET_COLOR = '\x1b[0m'
SEPARATOR = '---------------------------------------------------------------------------------------'

# Global counters
successful_blocks = 0
failed_blocks = 0
lock = threading.Lock()


def extract_error_message(response):
    """Extract error message from the response."""
    try:
        return response.json()['errors'][0]['message']
    except:
        return 'Not Found'


def get_userid_from_cookie(session, cookie, userids):
    """Retrieve user ID from the cookie."""
    try:
        response = session.get(
            'https://users.roblox.com/v1/users/authenticated',
            cookies={'.ROBLOSECURITY': cookie},
            timeout=3
        )
        user_data = response.json()
        with lock:
            userids.append(user_data.get('id'))
    except requests.exceptions.RequestException as e:
        print(f"{FAILURE_COLOR}Failed to retrieve user ID: {e}{RESET_COLOR}")

def block_users(session, cookie, userids):
    """Block users for a specific account."""
    global successful_blocks, failed_blocks

    try:
        response = session.post(
            'https://auth.roblox.com/v2/login',
            cookies={'.ROBLOSECURITY': cookie},
            timeout=3
        )
        csrf_token = response.headers.get('X-CSRF-TOKEN', '')

        # Fetch authenticated user name
        names = session.get(
            'https://users.roblox.com/v1/users/authenticated',
            cookies={'.ROBLOSECURITY': str(cookie).strip()},
            timeout=3
        )
        name = names.json().get('name', 'Not Found')

        for userid in userids:
            try:
                response = session.post(
                    f'https://accountsettings.roblox.com/v1/users/{userid}/block',
                    cookies={'.ROBLOSECURITY': cookie},
                    headers={'X-CSRF-TOKEN': csrf_token},
                    timeout=3
                )

                with lock:
                    if response.status_code == 200:
                        successful_blocks += 1
                        print(SEPARATOR)
                        print(f"{SUCCESS_COLOR}✓ SUCCESS: Account '{name}' blocked user with ID {userid}{RESET_COLOR}")
                        print(SEPARATOR)
                    else:
                        failed_blocks += 1
                        error_message = extract_error_message(response)
                        print(SEPARATOR)
                        print(f"{FAILURE_COLOR}✗ FAILURE: Account '{name}' could not block user with ID {userid}")
                        print(f'    Reason: {error_message}{RESET_COLOR}')
                        print(SEPARATOR)

            except requests.exceptions.RequestException as e:
                print(f"{FAILURE_COLOR}Request error: {e}{RESET_COLOR}")

    except requests.exceptions.RequestException as e:
        print(f"{FAILURE_COLOR}Failed to authenticate: {e}{RESET_COLOR}")


def block_worker(cookie, userids):
    """Thread worker for blocking users."""
    with requests.Session() as session:
        block_users(session, cookie, userids)


def user_id_worker(cookie, userids):
    """Thread worker for fetching user IDs."""
    with requests.Session() as session:
        get_userid_from_cookie(session, cookie, userids)


def block_accounts():
    """Main function to process blocking accounts."""
    start_time = datetime.now()

    # Read cookies from file
    if not os.path.exists('cookie.txt'):
        print(f"{FAILURE_COLOR}Error: 'cookie.txt' file not found!{RESET_COLOR}")
        return

    with open('cookie.txt', 'r') as file:
        cookies = []
        for line in file:
            parts = line.strip().split(':')
            if len(parts) == 4:
                cookies.append(':'.join(parts[2:]))
            else:
                cookies.append(line.strip())

    # Helper to divide cookies into chunks
    def chunkify(lst, chunk_size):
        for i in range(0, len(lst), chunk_size):
            yield lst[i:i + chunk_size]

    cookie_chunks = list(chunkify(cookies, 100))
    userids = []

    for chunk in cookie_chunks:
        userids = []
        threads = []

        # Fetch user IDs
        for cookie in chunk:
            t = threading.Thread(target=user_id_worker, args=(cookie, userids))
            t.start()
            threads.append(t)

        for t in threads:
            t.join()

        threads = []

        # Block users
        for cookie in chunk:
            t = threading.Thread(target=block_worker, args=(cookie, userids))
            t.start()
            threads.append(t)

        for t in threads:
            t.join()

    end_time = datetime.now()
    elapsed_time = end_time - start_time

    # Print summary
    print(SEPARATOR)
    print(f'{SUCCESS_COLOR}Total successful blocks: {successful_blocks}{RESET_COLOR}')
    print(f'{FAILURE_COLOR}Total failed blocks: {failed_blocks}{RESET_COLOR}')
    print(f'Time: {elapsed_time.total_seconds():.2f} seconds. Total cookies: {len(cookies)}')
    print(SEPARATOR)

def delete_roblox_cache():
    os.system("rm -rf /data/data/com.roblox.cliena/cache")
    os.system("rm -rf /data/data/com.roblox.clienb/cache")
    os.system("rm -rf /data/data/com.roblox.clienc/cache")  
    os.system("rm -rf /data/data/com.roblox.cliend/cache")
    os.system("rm -rf /data/data/com.roblox.cliene/cache")
    os.system("rm -rf /data/data/com.roblox.clienf/cache")
    os.system("rm -rf /data/data/com.roblox.clieng/cache")
    os.system("rm -rf /data/data/com.roblox.clienh/cache")
    os.system("rm -rf /data/data/com.roblox.clieni/cache")
    os.system("rm -rf /data/data/com.roblox.clienj/cache")
    os.system("rm -rf /data/data/com.roblox.clienk/cache")
    os.system("rm -rf /data/data/com.roblox.clienl/cache")
    os.system("rm -rf /data/data/com.roblox.clienn/cache")
    os.system("rm -rf /data/data/com.roblox.clienm/cache")
    os.system("rm -rf /data/data/com.roblox.clieno/cache")
    os.system("rm -rf /data/data/com.roblox.clienp/cache")
    os.system("rm -rf /data/data/com.roblox.clienq/cache")
    os.system("rm -rf /data/data/com.roblox.clienr/cache")
    os.system("rm -rf /data/data/com.roblox.cliens/cache")
    os.system("rm -rf /data/data/com.roblox.client/cache")
    os.system("rm -rf /data/data/com.roblox.clienu/cache")
    os.system("rm -rf /data/data/com.roblox.clienv/cache")
    os.system("rm -rf /data/data/com.roblox.clienw/cache")
    os.system("rm -rf /data/data/com.roblox.clienx/cache")
    os.system("rm -rf /data/data/com.roblox.clieny/cache")
    os.system("rm -rf /data/data/com.roblox.clienz/cache")
        
# Main function to handle auto rejoin
def main():
    clear_screen() 
    load_cache()  # Load the cache at the start
    
    print_header()

    while True:
        clear_screen()  # Clear screen each time to avoid overlapping
        print_header()  # Always print the header

        # Dynamic menu options
        menu_options = [
            "Start Auto Rejoin",
            "Set User IDs for Each Package",
            "Same Game ID or Private Server Link",
            "Different Private Server or Game ID",
            "Clear User IDs and/or Server Links",
            "List",
            "Auto Setup User IDs",
            "Bypass Start ( Fluxus / Delta ) (Patched Wait Fix)",
            "Same HWID Fluxus",
            "Auto Login via Cookie",            
            "Auto Logout",     
            "Check Cookies",   
            "Setup webhook",  
            "Set Up AutoExec",   
            "Block Account ( Prevent Join Same Server )",   
            "Exit"
        ]

        create_dynamic_menu(menu_options)  # Create the dynamic menu

        setup_type = input(Fore.LIGHTMAGENTA_EX + "Enter choice: " + Style.RESET_ALL)
        
        if setup_type == "1":
            server_links = load_server_links()
            accounts = load_accounts()

            if not accounts:
                print(Fore.RED + "No user IDs set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                continue
            elif not server_links:
                print(Fore.RED + "No game ID or private server link set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                continue

            try:
                force_rejoin_interval = int(input("Enter the force rejoin/kill Roblox interval in minutes: ")) * 60
                if force_rejoin_interval <= 0:
                    raise ValueError("The interval must be a positive integer.")
            except ValueError as ve:
                print(Fore.RED + f"Invalid input: {ve}. Please enter a valid interval in minutes." + Style.RESET_ALL)
                input(Fore.GREEN + "Press Enter to return to the menu..." + Style.RESET_ALL)
                continue

            package_statuses = {}
            for package_name, server_link in server_links:
                package_statuses[package_name] = {
                    "Status": Fore.LIGHTCYAN_EX + "Initializing" + Style.RESET_ALL,
                    "Username": get_username(accounts[server_links.index((package_name, server_link))][1]),
                }

            update_status_table(package_statuses)

            # Kill Roblox processes and wait for 5 seconds
            kill_roblox_processes()
            time.sleep(5)

            num_packages = len(server_links)

            for package_name, server_link in server_links:
                try:
                    package_statuses[package_name]["Status"] = Fore.LIGHTCYAN_EX + "Launching" + Style.RESET_ALL
                    update_status_table(package_statuses)
                    launch_roblox(package_name, server_link, num_packages, package_statuses)
                    package_statuses[package_name]["Status"] = Fore.GREEN + "Joined" + Style.RESET_ALL

                    # Get the username for the executor check
                    username = get_username(accounts[server_links.index((package_name, server_link))][1])

                    # Reset the executor file before checking
                    reset_executor_file(username)

                    # Ensure the tool waits for the executor to load before proceeding to the next package
                    while True:
                        if check_executor_status(username, continuous=False):
                            package_statuses[package_name]["Status"] = Fore.GREEN + f"Executor loaded successfully for {username}" + Style.RESET_ALL
                            update_status_table(package_statuses)
                            break  # Break the loop and proceed to the next package

                        # If the executor failed to load within 2 minutes, rejoin and retry
                        else:
                            print(f"Executor did not load for {package_name} (username: {username}). Rejoining...")
                            package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                            update_status_table(package_statuses)
                            kill_roblox_process(package_name)
                            time.sleep(2)
                            launch_roblox(package_name, server_link, num_packages, package_statuses)

                except Exception as e:
                    # Handle subprocess or launch error
                    print(Fore.RED + f"Error launching Roblox for {package_name}: {e}" + Style.RESET_ALL)
                    package_statuses[package_name]["Status"] = Fore.RED + "Launch failed" + Style.RESET_ALL
                update_status_table(package_statuses)

            start_time = time.time()

            while True:
                current_time = time.time()

                try:
                    for package_name, user_id in accounts:
                        try:
                            # Retrieve the correct server_link for the package_name
                            server_link = get_server_link(package_name, server_links)
                            if not server_link:
                                package_statuses[package_name]["Status"] = Fore.RED + "Server link not found" + Style.RESET_ALL
                                update_status_table(package_statuses)
                                continue

                            # Get the username associated with the user ID or fallback to user ID
                            username = get_username_from_id(user_id)
                            presence_type, last_location_current = check_user_online(user_id)

                            package_statuses[package_name]["Username"] = username

                            if presence_type == 2:
                                package_statuses[package_name]["Status"] = Fore.GREEN + "In-Game" + Style.RESET_ALL
                                
                                if not check_executor_status(username, continuous=False):  # If executor isn't detected as working
                                    print(f"Executor did not update for {package_name} (username: {username}). Rejoining...")
                                    package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                    update_status_table(package_statuses)
                                    kill_roblox_process(package_name)
                                    time.sleep(2)
                                    launch_roblox(package_name, server_link, num_packages, package_statuses)
                                    
                            else:
                                if not is_roblox_running(package_name):
                                    package_statuses[package_name]["Status"] = Fore.RED + "Process Crashed, Relaunching" + Style.RESET_ALL
                                    kill_roblox_process(package_name)
                                    time.sleep(2)
                                    launch_roblox(package_name, server_link, num_packages, package_statuses)
                                    
                                    # Check executor status after relaunch
                                    if not check_executor_status(username, continuous=False):
                                        print(f"Executor did not load for {package_name} (username: {username}) after relaunch. Rejoining...")
                                        package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                        kill_roblox_process(package_name)
                                        time.sleep(2)
                                        launch_roblox(package_name, server_link, num_packages, package_statuses)
                                    
                                else:
                                    if last_location_current == "Website":
                                        package_statuses[package_name]["Status"] = Fore.RED + "On Website, Rejoining" + Style.RESET_ALL
                                        kill_roblox_process(package_name)
                                        time.sleep(2)
                                        launch_roblox(package_name, server_link, num_packages, package_statuses)

                                        # Check executor status after relaunch
                                        if not check_executor_status(username, continuous=False):
                                            print(f"Executor did not load for {package_name} (username: {username}) after relaunch. Rejoining...")
                                            package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                            update_status_table(package_statuses)
                                            kill_roblox_process(package_name)
                                            time.sleep(2)
                                            launch_roblox(package_name, server_link, num_packages, package_statuses)

                                        # If executor loaded successfully after relaunch
                                        else:
                                            package_statuses[package_name]["Status"] = Fore.GREEN + "Executor loaded successfully after rejoin" + Style.RESET_ALL
                                            update_status_table(package_statuses)
                                    else:
                                        package_statuses[package_name]["Status"] = Fore.YELLOW + "Not In-Game, Recently Active" + Style.RESET_ALL

                            update_status_table(package_statuses)
                            time.sleep(25)  # Adjust the delay time as needed

                        except Exception as e:
                            print(Fore.RED + f"Error during rejoin process for {package_name}: {e}" + Style.RESET_ALL)
                            package_statuses[package_name]["Status"] = Fore.RED + "General error" + Style.RESET_ALL
                            update_status_table(package_statuses)

                    if current_time - start_time >= force_rejoin_interval:
                        print("Force killing Roblox processes due to time limit.")
                        kill_roblox_processes()
                        start_time = current_time
                        print(Fore.YELLOW + "Waiting for 5 seconds before starting the rejoin process..." + Style.RESET_ALL)
                        time.sleep(5)
                        for package_name, server_link in server_links:
                            try:
                                package_statuses[package_name]["Status"] = Fore.RED + "Rejoining" + Style.RESET_ALL
                                update_status_table(package_statuses)
                                launch_roblox(package_name, server_link, num_packages, package_statuses)
                                
                                # Check executor status after relaunch
                                if not check_executor_status(username, continuous=False):
                                    print(f"Executor did not load for {package_name} (username: {username}) after rejoin. Rejoining...")
                                    package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                    kill_roblox_process(package_name)
                                    time.sleep(2)
                                    launch_roblox(package_name, server_link, num_packages, package_statuses)

                                package_statuses[package_name]["Status"] = Fore.GREEN + "Joined" + Style.RESET_ALL
                            except Exception as e:
                                print(Fore.RED + f"Error rejoining Roblox for {package_name}: {e}" + Style.RESET_ALL)

                        update_status_table(package_statuses)

                    time.sleep(90)

                except Exception as e:
                    print(Fore.RED + f"Critical error in auto rejoin loop: {e}" + Style.RESET_ALL)
                    time.sleep(60)
                    continue
            
        elif setup_type == "2":
            accounts = []
            packages = get_roblox_packages()

            for package_name in packages:
                user_input = input(f"Enter the user ID or username for {package_name}: ")
                user_id = None

                if user_input.isdigit():
                    user_id = user_input
                else:
                    print(f"Retrieving user ID for username: {user_input}...")
                    user_id = asyncio.run(get_user_id(user_input))
                    if user_id is None:
                        print(Fore.RED + "Failed to retrieve user ID. Please enter the user ID manually." + Style.RESET_ALL)
                        user_id = input("Enter the user ID: ")

                accounts.append((package_name, user_id))
                print(f"Set {package_name} to user ID: {user_id}")

            save_accounts(accounts)
            save_cache()
            print(Fore.GREEN + "User IDs saved!" + Style.RESET_ALL)

            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 
            
        elif setup_type == "3":
            server_link = input("Enter the game ID or private server link: ")
            formatted_link = format_server_link(server_link)

            if formatted_link:
                packages = get_roblox_packages()
                server_links = [(package_name, formatted_link) for package_name in packages]
                save_server_links(server_links)
                print(Fore.GREEN + "Game ID or private server link saved successfully!" + Style.RESET_ALL)
                
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL)                 

        elif setup_type == "4":
            packages = get_roblox_packages()
            server_links = []

            for package_name in packages:
                server_link = input(f"Enter the game ID or private server link for {package_name}: ")
                formatted_link = format_server_link(server_link)

                if formatted_link:
                    server_links.append((package_name, formatted_link))

            save_server_links(server_links)  
            
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 
            
        elif setup_type == "5":
            clear_choice = input(Fore.GREEN + "What do you want to clear?\n1. Clear User IDs\n2. Clear Server Links\n3. Clear Both\nEnter choice: " + Style.RESET_ALL)

            if clear_choice == "1":
                if os.path.exists(ACCOUNTS_FILE):
                    os.remove(ACCOUNTS_FILE)
                    print(Fore.GREEN + "User IDs cleared successfully!" + Style.RESET_ALL)
                else:
                    print(Fore.YELLOW + f"No such file: '{ACCOUNTS_FILE}' found to clear." + Style.RESET_ALL)

            elif clear_choice == "2":
                if os.path.exists(SERVER_LINKS_FILE):
                    os.remove(SERVER_LINKS_FILE)
                    print(Fore.GREEN + "Server links cleared successfully!" + Style.RESET_ALL)
                else:
                    print(Fore.YELLOW + f"No such file: '{SERVER_LINKS_FILE}' found to clear." + Style.RESET_ALL)

            elif clear_choice == "3":
                if os.path.exists(ACCOUNTS_FILE):
                    os.remove(ACCOUNTS_FILE)
                    print(Fore.GREEN + "User IDs cleared successfully!" + Style.RESET_ALL)
                else:
                    print(Fore.YELLOW + f"No such file: '{ACCOUNTS_FILE}' found to clear." + Style.RESET_ALL)

                if os.path.exists(SERVER_LINKS_FILE):
                    os.remove(SERVER_LINKS_FILE)
                    print(Fore.GREEN + "Server links cleared successfully!" + Style.RESET_ALL)
                else:
                    print(Fore.YELLOW + f"No such file: '{SERVER_LINKS_FILE}' found to clear." + Style.RESET_ALL)
                    
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 
            
        elif setup_type == "6":
            accounts = load_accounts()
            server_links = load_server_links()

            if accounts and server_links:
                headers = ["Account", "Server", "Game ID", "Username"]
                rows = [(package, server, game_id, get_username(game_id)) for (package, game_id), (_, server) in zip(accounts, server_links)]
                create_dynamic_table(headers, rows)
            else:
                print(Fore.RED + "No accounts or server links to display." + Style.RESET_ALL)
            input(Fore.GREEN + "\nPress Enter to return to the menu..." + Style.RESET_ALL) 
        elif setup_type == "7":
            print(Fore.GREEN + "Auto Setup User IDs from each package's appStorage.json..." + Style.RESET_ALL)
            packages = get_roblox_packages()
            accounts = []

            for package_name in packages:
                file_path = f'/data/data/{package_name}/files/appData/LocalStorage/appStorage.json'
                user_id = find_userid_from_file(file_path)
                
                if user_id:
                    accounts.append((package_name, user_id))
                    print(f"Found UserId for {package_name}: {user_id}")
                else:
                    print(Fore.RED + f"UserId not found for {package_name}. Make sure the file path is correct and the format is as expected." + Style.RESET_ALL)

            save_accounts(accounts)
            save_cache()
            print(Fore.GREEN + "User IDs saved from appStorage.json!" + Style.RESET_ALL)

            # Prompt for server link
            server_link = input("Enter the game ID or private server link: ")
            formatted_link = format_server_link(server_link)

            if formatted_link:
                server_links = [(package_name, formatted_link) for package_name in packages]
                save_server_links(server_links)
                print(Fore.GREEN + "Game ID or private server link saved successfully!" + Style.RESET_ALL)
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 
            
        elif setup_type == "8":
            accounts = load_accounts()
            server_links = load_server_links()
            last_bypass_time = time.time()

            if not accounts:
                print(Fore.RED + "No user IDs set up yet! Please set them up before proceeding." + Style.RESET_ALL)
                continue

            try:
                force_rejoin_interval = int(input("Enter the force rejoin/kill Roblox interval in minutes: ")) * 60
                if force_rejoin_interval <= 0:
                    raise ValueError("The interval must be a positive integer.")
            except ValueError as ve:
                print(Fore.RED + f"Invalid input: {ve}. Please enter a valid interval in minutes." + Style.RESET_ALL)
                input(Fore.GREEN + "Press Enter to return to the menu..." + Style.RESET_ALL)
                continue

            print(Fore.GREEN + "Choose the executor:" + Style.RESET_ALL)
            print("1. Delta")
            print("2. Fluxus")
            executor_choice = input("Enter your choice (1-2): ")

            if executor_choice not in ["1", "2"]:
                print(Fore.RED + "Invalid choice. Please enter a valid option." + Style.RESET_ALL)
                continue

            minutes_left_dict = {} if executor_choice == "1" else None

            # Choose the bypass interval based on user input (only for Fluxus)
            bypass_interval = None
            if executor_choice == "2":
                print(Fore.GREEN + "Choose the bypass interval:" + Style.RESET_ALL)
                print("1. Every 30 minutes")
                print("2. Every 1 hour")
                print("3. Every 2 hours")
                print("4. Every 12 hours")
                interval_choice = input("Enter your choice (1-4): ")
                bypass_interval_mapping = {
                   '1': 30 * 60,  # 30 minutes in seconds
                   '2': 60 * 60,  # 1 hour in seconds
                   '3': 2 * 60 * 60,  # 2 hours in seconds
                   '4': 12 * 60 * 60  # 12 hours in seconds
                }
                bypass_interval = bypass_interval_mapping.get(interval_choice)
                if not bypass_interval:
                    print(Fore.RED + "Invalid choice. Please enter a valid option." + Style.RESET_ALL)
                    continue

            package_statuses = {}
            for package_name, _ in server_links:
                package_statuses[package_name] = {
                    "Status": Fore.LIGHTCYAN_EX + "Initializing" + Style.RESET_ALL,
                    "Username": get_username(accounts[server_links.index((package_name, _))][1]),
                }

            update_status_table(package_statuses)  # Initial table update

            if executor_choice == "1":
                for package_name in accounts:
                    try:
                        if package_name not in minutes_left_dict or minutes_left_dict[package_name] == "0H 0M":
                            hwid = get_hwid_platoboost()
                            bypassed_links = bypass_user_ids([(package_name, None)], "1", minutes_left_dict)
                            
                            if bypassed_links:
                                package_statuses[package_name]["Status"] = Fore.GREEN + "Delta Bypass successful" + Style.RESET_ALL
                            else:
                                package_statuses[package_name]["Status"] = Fore.RED + "Failed to bypass using Delta" + Style.RESET_ALL
                        else:
                            print(Fore.YELLOW + f"{package_name}: Waiting for {minutes_left_dict[package_name]} before rebypass..." + Style.RESET_ALL)
                    
                    except Exception as e:
                        package_statuses[package_name]["Status"] = Fore.RED + f"Error during Delta Bypass: {e}" + Style.RESET_ALL
                    
                    update_status_table(package_statuses)

            elif executor_choice == "2":
                for package_name in accounts:
                    hwid = get_hwid(package_name)
                    if hwid:
                        bypass_link = create_fluxus_bypass_link(hwid)
                        try:
                            response = requests.get(bypass_link)
                            if response.status_code == 200:
                                bypass_result = response.json()
                                package_statuses[package_name]["Status"] = Fore.GREEN + "Fluxus Bypass successful" + Style.RESET_ALL
                            else:
                                package_statuses[package_name]["Status"] = Fore.RED + f"Fluxus Bypass failed with status code {response.status_code}" + Style.RESET_ALL
                        except Exception as e:
                            package_statuses[package_name]["Status"] = Fore.RED + f"Error during Fluxus Bypass: {e}" + Style.RESET_ALL
                    else:
                        package_statuses[package_name]["Status"] = Fore.RED + "Failed to retrieve HWID" + Style.RESET_ALL
                    update_status_table(package_statuses)

            # Kill Roblox processes and wait for 5 seconds
            print("Killing Roblox processes...")
            kill_roblox_processes()
            print(Fore.YELLOW + "Waiting for 5 seconds before starting the rejoin process..." + Style.RESET_ALL)
            time.sleep(5)
            num_packages = len(server_links)

            # Launch Roblox and check executor for each package
            for package_name, server_link in server_links:
                try:
                    # Launch Roblox
                    launch_roblox(package_name, server_link, num_packages, package_statuses)

                    # Get the username for the executor check
                    username = get_username(accounts[server_links.index((package_name, server_link))][1])

                    # Check if executor is loaded, if not, rejoin
                    reset_executor_file(username)

                    # Ensure the tool waits for the executor to load before proceeding to the next package
                    while True:
                        if check_executor_status(username, continuous=False):
                            package_statuses[package_name]["Status"] = Fore.GREEN + f"Executor loaded successfully for {username}" + Style.RESET_ALL
                            update_status_table(package_statuses)
                            break  # Break the loop and proceed to the next package

                        # If the executor failed to load within 2 minutes, rejoin and retry
                        else:
                            print(f"Executor did not load for {package_name} (username: {username}). Rejoining...")
                            package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                            update_status_table(package_statuses)
                            kill_roblox_process(package_name)
                            time.sleep(2)
                            launch_roblox(package_name, server_link, num_packages, package_statuses)

                except Exception as e:
                    # Handle subprocess or launch error
                    print(Fore.RED + f"Error launching Roblox for {package_name}: {e}" + Style.RESET_ALL)
                    package_statuses[package_name]["Status"] = Fore.RED + "Launch failed" + Style.RESET_ALL
                update_status_table(package_statuses)

            start_time = time.time()
            last_bypass_time = start_time

            try:
                while True:
                    current_time = time.time()

                    for package_name, user_id in accounts:
                        username = get_username(user_id) or user_id
                        presence_type, last_location_current = check_user_online(user_id)

                        package_statuses[package_name]["Username"] = username

                        if presence_type == 2:
                            package_statuses[package_name]["Status"] = Fore.GREEN + "In-Game" + Style.RESET_ALL
                            
                            if not check_executor_status(username, continuous=False):  # If executor isn't detected as working
                                print(f"Executor did not update for {package_name} (username: {username}). Rejoining...")
                                package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                update_status_table(package_statuses)
                                kill_roblox_process(package_name)
                                time.sleep(2)
                                launch_roblox(package_name, server_link, num_packages, package_statuses)
                                
                        else:
                            if not is_roblox_running(package_name):
                                package_statuses[package_name]["Status"] = Fore.RED + "Process Crashed, Relaunching" + Style.RESET_ALL
                                kill_roblox_process(package_name)
                                time.sleep(2)
                                launch_roblox(package_name, server_link, num_packages, package_statuses)
                                
                                # Check executor status after relaunch
                                if not check_executor_status(username, continuous=False):
                                    print(f"Executor did not load for {package_name} (username: {username}) after relaunch. Rejoining...")
                                    package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                    kill_roblox_process(package_name)
                                    time.sleep(2)
                                    launch_roblox(package_name, server_link, num_packages, package_statuses)

                                # If executor loaded successfully after relaunch
                                else:
                                    if last_location_current == "Website":
                                        package_statuses[package_name]["Status"] = Fore.RED + "On Website, Rejoining" + Style.RESET_ALL
                                        kill_roblox_process(package_name)
                                        time.sleep(2)
                                        launch_roblox(package_name, server_link, num_packages, package_statuses)

                                        # Check executor status after relaunch
                                        if not check_executor_status(username, continuous=False):
                                            print(f"Executor did not load for {package_name} (username: {username}) after relaunch. Rejoining...")
                                            package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                            update_status_table(package_statuses)
                                            kill_roblox_process(package_name)
                                            time.sleep(2)
                                            launch_roblox(package_name, server_link, num_packages, package_statuses)

                                        # If executor loaded successfully after relaunch
                                        else:
                                            package_statuses[package_name]["Status"] = Fore.GREEN + "Executor loaded successfully after rejoin" + Style.RESET_ALL
                                            update_status_table(package_statuses)
                                    else:
                                        package_statuses[package_name]["Status"] = Fore.YELLOW + "Not In-Game, Recently Active" + Style.RESET_ALL

                        update_status_table(package_statuses)
                        time.sleep(25)  # Adjust the delay time as needed

                    if executor_choice == "1":  # Delta
                        # Check remaining time and rebypass if needed
                        for package_name, user_id in accounts:
                            bypass_results = bypass_user_ids(accounts, "1", minutes_left_dict)
                            for _, result in bypass_results:
                                minutes_left = result.get('minutesLeft', "0H 0M")
                                if minutes_left == "0H 0M":
                                    package_statuses[package_name]["Status"] = Fore.RED + "Bypassing Now..." + Style.RESET_ALL
                                    update_status_table(package_statuses)
                                    bypass_user_ids(accounts, "1", minutes_left_dict)  # Rebypass immediately if minutes left is 0 or less
                        update_status_table(package_statuses)

                    if executor_choice == "2" and current_time - last_bypass_time >= bypass_interval:
                        print("Performing Fluxus bypass operation...")
                        bypass_results = bypass_user_ids(accounts, "2")  # No need to pass minutes_left_dict
                        last_bypass_time = current_time

                    time.sleep(90)  # Wait 90 seconds before the next loop iteration

                    if current_time - start_time >= force_rejoin_interval:
                        print("Force killing Roblox processes due to time limit.")
                        kill_roblox_processes()
                        start_time = current_time
                        print(Fore.YELLOW + "Waiting for 5 seconds before starting the rejoin process..." + Style.RESET_ALL)
                        time.sleep(5)
                        for package_name, server_link in server_links:
                            try:
                                package_statuses[package_name]["Status"] = Fore.RED + "Rejoining" + Style.RESET_ALL
                                update_status_table(package_statuses)
                                launch_roblox(package_name, server_link, num_packages, package_statuses)
                                
                                # Check executor status after relaunch
                                if not check_executor_status(username, continuous=False):
                                    print(f"Executor did not load for {package_name} (username: {username}) after rejoin. Rejoining...")
                                    package_statuses[package_name]["Status"] = Fore.RED + "Executor failed, rejoining..." + Style.RESET_ALL
                                    kill_roblox_process(package_name)
                                    time.sleep(2)
                                    launch_roblox(package_name, server_link, num_packages, package_statuses)

                                package_statuses[package_name]["Status"] = Fore.GREEN + "Joined" + Style.RESET_ALL
                            except Exception as e:
                                print(Fore.RED + f"Error rejoining Roblox for {package_name}: {e}" + Style.RESET_ALL)

                        update_status_table(package_statuses)

            except Exception as e:
                print(Fore.RED + f"Critical error in bypass process: {e}" + Style.RESET_ALL)
                time.sleep(60)
                continue
            
        elif setup_type == "9":
            new_hwid = input("Enter the new HWID you want to set for all Fluxus packages: ")

            # Fetch the Fluxus packages
            packages = get_roblox_packages()

            # Iterate over each package and update the HWID
            for package_name in packages:
                hwid_file_path = get_hwid_file_path(package_name)
                if hwid_file_path:
                    try:
                        with open(hwid_file_path, "w") as file:
                            file.write(new_hwid)
                        print(Fore.GREEN + f"HWID for {package_name} successfully updated to {new_hwid}" + Style.RESET_ALL)
                    except Exception as e:
                        print(Fore.RED + f"Error updating HWID for {package_name}: {e}" + Style.RESET_ALL)
                else:
                    print(Fore.RED + f"Failed to find HWID file for {package_name}. Skipping." + Style.RESET_ALL)

            input(Fore.GREEN + "\nPress Enter to return to the menu..." + Style.RESET_ALL)
            
        elif setup_type == "10":  # Auto Login via Cookie
            inject_cookies_and_appstorage()
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 

        elif setup_type == "11":  # Auto Logout
            logout_roblox()
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 

        elif setup_type == "12":  # Check Cookie
            check_cookies_from_file('cookie.txt')
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 

        elif setup_type == "13":  # webhook
            setup_webhook()
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 

        elif setup_type == "14":  # Set Up AutoExec
            create_autoexc_folder()
            push_autoexc_files()
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 

        elif setup_type == "15":  # Block Account 
            os.system('cls' if os.name == 'nt' else 'clear')
            block_accounts()
            input(Fore.GREEN + "\nPress Enter to exit..." + Style.RESET_ALL) 
            
        elif setup_type == "16":
            global stop_webhook_thread
            stop_webhook_thread = True  # Stop the webhook thread if it is running
            break 

if __name__ == "__main__":
    load_cache()  # Load the cache at the start
    delete_roblox_cache() # Delete Roblox Cache at the start
    main()  # Run the main function
    save_cache()  # Save the cache before exiting
